// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2084.CMonster2018;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

import org.usfirst.frc2084.CMonster2018.PID.DistancePID;
import org.usfirst.frc2084.CMonster2018.PID.HeadingPID;

import com.ctre.*;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
   
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	
	
	public static WPI_TalonSRX driveBaseRightTalon1;
	public static WPI_TalonSRX driveBaseLeftTalon1;
	public static WPI_VictorSPX driveBaseRightVictor1;
	public static WPI_VictorSPX driveBaseLeftVictor1;
	public static WPI_TalonSRX elevatorTalon;
	public static SpeedController climberSpark;
	public static SpeedController rightIntakeSpark;
	public static SpeedController leftIntakeSpark;

	
	
	public static PIDController driveBaseRightPIDController;
	public static PIDController driveBaseLeftPIDController;
	public static Encoder driveBaseLeftEncoder;
	public static Encoder driveBaseRightEncoder;
	
	public static DistancePID distancePID = new DistancePID();
	public static HeadingPID headingPID = new HeadingPID();
	
	public static double AverageDistance;
	public static double talonOutput;
	
	public static AHRS ahrs; //the navX
	
	
	public static final double DRIVE_SUBSYSTEM_WHEEL_DIAMETER = 0.3333333;
	public static final double DISTANCE_PER_ROTATION = Math.PI * 0.3333333;
	
	
    public static void init() {
    	

    	driveBaseLeftTalon1 = new WPI_TalonSRX(2);
    	driveBaseRightTalon1 = new WPI_TalonSRX(4);
    	driveBaseLeftVictor1 = new WPI_VictorSPX(3);
    	driveBaseRightVictor1 = new WPI_VictorSPX(5);
    	elevatorTalon = new WPI_TalonSRX(6);
    	
    	climberSpark = new Spark(0); //number is the pwm channels on the roboRIO
    	rightIntakeSpark = new Spark(1);
    	leftIntakeSpark = new Spark(2);
    	
    	
    	final HeadingPID headingPID = new HeadingPID();
    	final DistancePID distancePID = new DistancePID();
    	
    	
    	driveBaseLeftTalon1.set(ControlMode.PercentOutput, talonOutput);
    	driveBaseRightTalon1.set(ControlMode.PercentOutput, talonOutput);
    	elevatorTalon.set(ControlMode.PercentOutput, talonOutput);
    	//controlMode could be either velocity or percentOutput
    	
    	
    	driveBaseLeftVictor1.set(ControlMode.Follower, talonOutput);
    	driveBaseRightVictor1.set(ControlMode.Follower, talonOutput);
    	driveBaseRightVictor1.follow(driveBaseRightTalon1);
    	driveBaseLeftVictor1.follow(driveBaseLeftTalon1);
    
    	
    	
    	//set feedback device
    	driveBaseLeftTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, 10);
    	driveBaseRightTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 1, 10);
    	
    	
    	//setF term
    	
    	
    	//set nominal/peak outputs voltage
    			driveBaseLeftTalon1.configNominalOutputForward(+0.0f, 0);
    			driveBaseRightTalon1.configNominalOutputReverse(-0.0f, 0);
    			driveBaseLeftTalon1.configPeakOutputForward(+12.0f, 12);
    			driveBaseRightTalon1.configPeakOutputReverse(-12.0f, -12);
    			
    			elevatorTalon.configNominalOutputForward(+0.0f, 0);
    			elevatorTalon.configPeakOutputForward(+12.0f, 12);
    			

    			ahrs = new AHRS(I2C.Port.kMXP, (byte) 100); // the navX!!
    			//needed to import I2C above
    	
    }
    
    
}
