// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc2084.CMonster2018;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.I2C;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.Spark;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;

import org.usfirst.frc2084.CMonster2018.PID.DistancePID;
import org.usfirst.frc2084.CMonster2018.PID.HeadingPID;

import com.ctre.*;
import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.can.TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_TalonSRX;
import com.ctre.phoenix.motorcontrol.can.WPI_VictorSPX;
import com.kauailabs.navx.frc.AHRS;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.Compressor;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.smartdashboard.*;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import edu.wpi.first.wpilibj.livewindow.LiveWindow;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static Encoder driveBaseRightEncoder;
    public static SpeedController driveBaseRightTalon1;
    public static PIDController driveBaseRightPIDController;
    public static Encoder driveBaseLeftEncoder;
    public static SpeedController driveBaseLeftTalon1;
    public static PIDController driveBaseLeftPIDController;
    public static Compressor driveBaseCompressor;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	
	
	public static WPI_TalonSRX driveBaseRightTalon1;
	public static WPI_TalonSRX driveBaseLeftTalon1;
	public static WPI_VictorSPX driveBaseRightVictor1;
	public static WPI_VictorSPX driveBaseLeftVictor1;
	public static WPI_TalonSRX elevatorTalon;
	public static SpeedController climberSpark;
	public static SpeedController rightIntakeSpark;
	public static SpeedController leftIntakeSpark;

	
	
	public static PIDController driveBaseRightPIDController;
	public static PIDController driveBaseLeftPIDController;
	public static Encoder driveBaseLeftEncoder;
	public static Encoder driveBaseRightEncoder;
	
	public static DistancePID distancePID = new DistancePID();
	public static HeadingPID headingPID = new HeadingPID();
	
	public static double AverageDistance;
	public static double talonOutput;
	
	public static AHRS ahrs; //the navX
	
	
	public static final double DRIVE_SUBSYSTEM_WHEEL_DIAMETER = 0.3333333;
	public static final double DISTANCE_PER_ROTATION = Math.PI * 0.3333333;
	
	
    public static void init() {
    	

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveBaseRightEncoder = new Encoder(0, 1, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveBase", "RightEncoder", driveBaseRightEncoder);
        driveBaseRightEncoder.setDistancePerPulse(1.0);
        driveBaseRightEncoder.setPIDSourceType(PIDSourceType.kRate);
        driveBaseRightTalon1 = new Talon(0);
        LiveWindow.addActuator("DriveBase", "RightTalon1", (Talon) driveBaseRightTalon1);
        driveBaseRightTalon1.setInverted(false);
        driveBaseRightPIDController = new PIDController(1.0, 0.0, 0.0, 0.0, driveBaseRightEncoder, driveBaseRightTalon1, 0.02);
        LiveWindow.addActuator("DriveBase", "RightPIDController", driveBaseRightPIDController);
        driveBaseRightPIDController.setContinuous(false);
        driveBaseRightPIDController.setAbsoluteTolerance(0.2);

        driveBaseRightPIDController.setOutputRange(-1.0, 1.0);
        driveBaseLeftEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        LiveWindow.addSensor("DriveBase", "LeftEncoder", driveBaseLeftEncoder);
        driveBaseLeftEncoder.setDistancePerPulse(1.0);
        driveBaseLeftEncoder.setPIDSourceType(PIDSourceType.kRate);
        driveBaseLeftTalon1 = new Talon(1);
        LiveWindow.addActuator("DriveBase", "LeftTalon1", (Talon) driveBaseLeftTalon1);
        driveBaseLeftTalon1.setInverted(false);
        driveBaseLeftPIDController = new PIDController(1.0, 0.0, 0.0, 0.0, driveBaseLeftEncoder, driveBaseLeftTalon1, 0.02);
        LiveWindow.addActuator("DriveBase", "LeftPIDController", driveBaseLeftPIDController);
        driveBaseLeftPIDController.setContinuous(false);
        driveBaseLeftPIDController.setAbsoluteTolerance(0.2);

        driveBaseLeftPIDController.setOutputRange(-1.0, 1.0);
        driveBaseCompressor = new Compressor(0);
        LiveWindow.addActuator("DriveBase", "Compressor", driveBaseCompressor);
        

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    	
    	driveBaseLeftTalon1 = new WPI_TalonSRX(2);
    	driveBaseRightTalon1 = new WPI_TalonSRX(4);
    	driveBaseLeftVictor1 = new WPI_VictorSPX(3);
    	driveBaseRightVictor1 = new WPI_VictorSPX(5);
    	elevatorTalon = new WPI_TalonSRX(6);
    	
    	climberSpark = new Spark(0); //number is the pwm channels on the roboRIO
    	rightIntakeSpark = new Spark(1);
    	leftIntakeSpark = new Spark(2);
    	
    	
    	final HeadingPID headingPID = new HeadingPID();
    	final DistancePID distancePID = new DistancePID();
    	
    	
    	driveBaseLeftTalon1.set(ControlMode.PercentOutput, talonOutput);
    	driveBaseRightTalon1.set(ControlMode.PercentOutput, talonOutput);
    	elevatorTalon.set(ControlMode.PercentOutput, talonOutput);
    	//controlMode could be either velocity or percentOutput
    	
    	driveBaseLeftVictor1.follow(driveBaseLeftTalon1);
    	driveBaseRightVictor1.follow(driveBaseRightTalon1);
    	
    	//set feedback device
    	driveBaseLeftTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 0, 10);
    	driveBaseRightTalon1.configSelectedFeedbackSensor(FeedbackDevice.CTRE_MagEncoder_Absolute, 1, 10);
    	//what do the 3 integer arguments represent??
    	
    	//setF term
    	
    	
    	//set nominal/peak outputs voltage
    			driveBaseLeftTalon1.configNominalOutputForward(+0.0f, 0);
    			driveBaseRightTalon1.configNominalOutputReverse(-0.0f, 0);
    			driveBaseLeftTalon1.configPeakOutputForward(+12.0f, 12);
    			driveBaseRightTalon1.configPeakOutputReverse(-12.0f, -12);
    			
    			elevatorTalon.configNominalOutputForward(+0.0f, 0);
    			elevatorTalon.configPeakOutputForward(+12.0f, 12);
    			

    			ahrs = new AHRS(I2C.Port.kMXP, (byte) 100); // the navX!!
    			//needed to import I2C above
    	
    }
    
    
}
